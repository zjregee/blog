<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="# 一、基本介绍 fd 是一个 Rust 实现的用于在文件系统中寻找文件和目录项的命令行程序，提供了一系列简单、快速、用户友好的功能。fd 旨在替代 find 命令。find 命令是在 Unix 和类 Unix 操作系统中使用的一个强大的命令行工具，用于在文件系统中搜索文件和目录。find 命令的基本语法如下： 1 find [起始目录] [匹配条件] [动作] 其中起始目录指定搜索的起始目录，匹配条件用于指定搜索文件的条件，可以是文件名、文件类型、文件大小等，动作用于指定在找到匹配项后执行的动作，例如打印文件名、删除文件等。作为替代的 find 的 fd，fd 有如下特征： 更直观的语法； 基于正则表达式和 glob 的模式匹配； 并行的目录遍历，大幅度的速度优化； 使用颜色来突出显示不同类型的文件； 并行命令执行的支持； 智能大小写处理； 默认情况下忽略隐藏的目录和文件； 默认情况下，忽略 .gitignore 中的模式匹配。 1）基于 glob 的模式匹配是一种用于匹配文件路径或名称的简单模式匹配方法，通常在命令行中使用。这种模式使用通配符来表示匹配一类文件或目录的模式，相较于正则表达式更加简单，语法和功能有一定限制。在很多情况下是一种简便而有效来指定文件路径的模式。 2）根据作者提供的测试数据，fd 相较于 find 命令可以取得一个数量级上的性能提升。fd 速度上的性能提升主要归功于并行的目录遍历以及相关正则表达式处理库。 fd 可以实现多种方式的搜索，例如根据包含指定字符串的搜索、正则表达式搜索、指定根目录的搜索、搜索一个特定的文件扩展名、搜索一个特定的文件名、搜索隐藏和忽略的文件、匹配完整路径的搜索、执行命令的搜索、排除特定文件或目录的搜索，也可以将多种搜索条件在一次搜索中进行表达。 作为 Github 上的明星项目，fd 已有近 30k 的 star 数，同时也是基于 Rust 实现的诸多命令行工具中最具有代表性的项目之一。本文将会大致介绍 fd 的整体框架和实现逻辑，值得一提的是命令行程序会有诸多不可避免的实现上的繁琐性，对于一些细节代码，本文不会做过多展开。 # 二、整体框架 fd 使用了 jemalloc 内存分配器替换了默认的系统内存分配器。Rust 提供了一种插件式的内存分配器接口，允许开发者使用不同的内存分配器。jemalloc 是一种高效的内存分配器，尤其适用于多线程的应用程序，同时提供了内存分析能力。 # 三、过滤筛选 fd 作为一个强大、易用的检索工具，提供了多种过滤筛选的方式。"><title>新一代文件系统检索命令行工具 fd 源码阅读</title>
<link rel=canonical href=https://zjregee.github.io/blog/p/fd/><link rel=stylesheet href=/blog/scss/style.min.8e60baf4cd3fc55968717a6e39762f4d28ed7ef6007566b6c7970ad0fe907198.css><meta property='og:title' content="新一代文件系统检索命令行工具 fd 源码阅读"><meta property='og:description' content="# 一、基本介绍 fd 是一个 Rust 实现的用于在文件系统中寻找文件和目录项的命令行程序，提供了一系列简单、快速、用户友好的功能。fd 旨在替代 find 命令。find 命令是在 Unix 和类 Unix 操作系统中使用的一个强大的命令行工具，用于在文件系统中搜索文件和目录。find 命令的基本语法如下： 1 find [起始目录] [匹配条件] [动作] 其中起始目录指定搜索的起始目录，匹配条件用于指定搜索文件的条件，可以是文件名、文件类型、文件大小等，动作用于指定在找到匹配项后执行的动作，例如打印文件名、删除文件等。作为替代的 find 的 fd，fd 有如下特征： 更直观的语法； 基于正则表达式和 glob 的模式匹配； 并行的目录遍历，大幅度的速度优化； 使用颜色来突出显示不同类型的文件； 并行命令执行的支持； 智能大小写处理； 默认情况下忽略隐藏的目录和文件； 默认情况下，忽略 .gitignore 中的模式匹配。 1）基于 glob 的模式匹配是一种用于匹配文件路径或名称的简单模式匹配方法，通常在命令行中使用。这种模式使用通配符来表示匹配一类文件或目录的模式，相较于正则表达式更加简单，语法和功能有一定限制。在很多情况下是一种简便而有效来指定文件路径的模式。 2）根据作者提供的测试数据，fd 相较于 find 命令可以取得一个数量级上的性能提升。fd 速度上的性能提升主要归功于并行的目录遍历以及相关正则表达式处理库。 fd 可以实现多种方式的搜索，例如根据包含指定字符串的搜索、正则表达式搜索、指定根目录的搜索、搜索一个特定的文件扩展名、搜索一个特定的文件名、搜索隐藏和忽略的文件、匹配完整路径的搜索、执行命令的搜索、排除特定文件或目录的搜索，也可以将多种搜索条件在一次搜索中进行表达。 作为 Github 上的明星项目，fd 已有近 30k 的 star 数，同时也是基于 Rust 实现的诸多命令行工具中最具有代表性的项目之一。本文将会大致介绍 fd 的整体框架和实现逻辑，值得一提的是命令行程序会有诸多不可避免的实现上的繁琐性，对于一些细节代码，本文不会做过多展开。 # 二、整体框架 fd 使用了 jemalloc 内存分配器替换了默认的系统内存分配器。Rust 提供了一种插件式的内存分配器接口，允许开发者使用不同的内存分配器。jemalloc 是一种高效的内存分配器，尤其适用于多线程的应用程序，同时提供了内存分析能力。 # 三、过滤筛选 fd 作为一个强大、易用的检索工具，提供了多种过滤筛选的方式。"><meta property='og:url' content='https://zjregee.github.io/blog/p/fd/'><meta property='og:site_name' content='zjregee'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Rust'><meta property='article:published_time' content='2023-08-17T00:00:00+00:00'><meta property='article:modified_time' content='2023-08-17T00:00:00+00:00'><meta property='og:image' content='https://zjregee.github.io/blog/p/fd/cover.jpg'><meta name=twitter:title content="新一代文件系统检索命令行工具 fd 源码阅读"><meta name=twitter:description content="# 一、基本介绍 fd 是一个 Rust 实现的用于在文件系统中寻找文件和目录项的命令行程序，提供了一系列简单、快速、用户友好的功能。fd 旨在替代 find 命令。find 命令是在 Unix 和类 Unix 操作系统中使用的一个强大的命令行工具，用于在文件系统中搜索文件和目录。find 命令的基本语法如下： 1 find [起始目录] [匹配条件] [动作] 其中起始目录指定搜索的起始目录，匹配条件用于指定搜索文件的条件，可以是文件名、文件类型、文件大小等，动作用于指定在找到匹配项后执行的动作，例如打印文件名、删除文件等。作为替代的 find 的 fd，fd 有如下特征： 更直观的语法； 基于正则表达式和 glob 的模式匹配； 并行的目录遍历，大幅度的速度优化； 使用颜色来突出显示不同类型的文件； 并行命令执行的支持； 智能大小写处理； 默认情况下忽略隐藏的目录和文件； 默认情况下，忽略 .gitignore 中的模式匹配。 1）基于 glob 的模式匹配是一种用于匹配文件路径或名称的简单模式匹配方法，通常在命令行中使用。这种模式使用通配符来表示匹配一类文件或目录的模式，相较于正则表达式更加简单，语法和功能有一定限制。在很多情况下是一种简便而有效来指定文件路径的模式。 2）根据作者提供的测试数据，fd 相较于 find 命令可以取得一个数量级上的性能提升。fd 速度上的性能提升主要归功于并行的目录遍历以及相关正则表达式处理库。 fd 可以实现多种方式的搜索，例如根据包含指定字符串的搜索、正则表达式搜索、指定根目录的搜索、搜索一个特定的文件扩展名、搜索一个特定的文件名、搜索隐藏和忽略的文件、匹配完整路径的搜索、执行命令的搜索、排除特定文件或目录的搜索，也可以将多种搜索条件在一次搜索中进行表达。 作为 Github 上的明星项目，fd 已有近 30k 的 star 数，同时也是基于 Rust 实现的诸多命令行工具中最具有代表性的项目之一。本文将会大致介绍 fd 的整体框架和实现逻辑，值得一提的是命令行程序会有诸多不可避免的实现上的繁琐性，对于一些细节代码，本文不会做过多展开。 # 二、整体框架 fd 使用了 jemalloc 内存分配器替换了默认的系统内存分配器。Rust 提供了一种插件式的内存分配器接口，允许开发者使用不同的内存分配器。jemalloc 是一种高效的内存分配器，尤其适用于多线程的应用程序，同时提供了内存分析能力。 # 三、过滤筛选 fd 作为一个强大、易用的检索工具，提供了多种过滤筛选的方式。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://zjregee.github.io/blog/p/fd/cover.jpg'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/><img src=/blog/img/avatar_huf8b2b345a9bb285ed8c532b05217afba_16572_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>👻</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>zjregee</a></h1><h2 class=site-description>Enjoy The Moment.</h2></div></header><ol class=menu id=main-menu><li><a href=/blog/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/blog/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#一基本介绍>一、基本介绍</a></li><li><a href=#二整体框架>二、整体框架</a></li><li><a href=#三过滤筛选>三、过滤筛选</a><ul><li><a href=#31-基于类型的筛选>3.1 基于类型的筛选</a></li><li><a href=#32-基于权限的筛选>3.2 基于权限的筛选</a></li><li><a href=#33-基于大小的筛选>3.3 基于大小的筛选</a></li><li><a href=#34-基于时间的筛选>3.4 基于时间的筛选</a></li></ul></li><li><a href=#四文件系统遍历>四、文件系统遍历</a><ul><li><a href=#41-数据结构抽象>4.1 数据结构抽象</a></li><li><a href=#42-并行遍历模式>4.2 并行遍历模式</a><ul><li><a href=#421-数据接收缓存>4.2.1 数据接收缓存</a></li><li><a href=#422-并行数据发送>4.2.2 并行数据发送</a></li></ul></li></ul></li><li><a href=#五命令执行模型>五、命令执行模型</a><ul><li><a href=#51-命令相关数据结构抽象>5.1 命令相关数据结构抽象</a></li><li><a href=#52-commandset-数据结构>5.2 CommandSet 数据结构</a></li></ul></li></ul></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/p/fd/><img src=/blog/p/fd/cover_hu5d8acb1e814c36457f6782e122fe0ff3_366641_800x0_resize_q75_box.jpg srcset="/blog/p/fd/cover_hu5d8acb1e814c36457f6782e122fe0ff3_366641_800x0_resize_q75_box.jpg 800w, /blog/p/fd/cover_hu5d8acb1e814c36457f6782e122fe0ff3_366641_1600x0_resize_q75_box.jpg 1600w" width=800 height=580 loading=lazy alt="Featured image of post 新一代文件系统检索命令行工具 fd 源码阅读"></a></div><div class=article-details><header class=article-category><a href=/blog/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/>源码阅读系列</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/p/fd/>新一代文件系统检索命令行工具 fd 源码阅读</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 17, 2023</time></div></footer></div></header><section class=article-content><h2 id=一基本介绍><a href=#%e4%b8%80%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d>#</a>
一、基本介绍</h2><p>fd 是一个 Rust 实现的用于在文件系统中寻找文件和目录项的命令行程序，提供了一系列简单、快速、用户友好的功能。fd 旨在替代 find 命令。find 命令是在 Unix 和类 Unix 操作系统中使用的一个强大的命令行工具，用于在文件系统中搜索文件和目录。find 命令的基本语法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=line><span class=cl>find <span class=o>[</span>起始目录<span class=o>]</span> <span class=o>[</span>匹配条件<span class=o>]</span> <span class=o>[</span>动作<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>其中起始目录指定搜索的起始目录，匹配条件用于指定搜索文件的条件，可以是文件名、文件类型、文件大小等，动作用于指定在找到匹配项后执行的动作，例如打印文件名、删除文件等。作为替代的 find 的 fd，fd 有如下特征：</p><ul><li>更直观的语法；</li><li>基于正则表达式和 glob 的模式匹配；</li><li>并行的目录遍历，大幅度的速度优化；</li><li>使用颜色来突出显示不同类型的文件；</li><li>并行命令执行的支持；</li><li>智能大小写处理；</li><li>默认情况下忽略隐藏的目录和文件；</li><li>默认情况下，忽略 .gitignore 中的模式匹配。</li></ul><blockquote><p>1）基于 glob 的模式匹配是一种用于匹配文件路径或名称的简单模式匹配方法，通常在命令行中使用。这种模式使用通配符来表示匹配一类文件或目录的模式，相较于正则表达式更加简单，语法和功能有一定限制。在很多情况下是一种简便而有效来指定文件路径的模式。</p><p>2）根据作者提供的测试数据，fd 相较于 find 命令可以取得一个数量级上的性能提升。fd 速度上的性能提升主要归功于并行的目录遍历以及相关正则表达式处理库。</p></blockquote><p>fd 可以实现多种方式的搜索，例如根据包含指定字符串的搜索、正则表达式搜索、指定根目录的搜索、搜索一个特定的文件扩展名、搜索一个特定的文件名、搜索隐藏和忽略的文件、匹配完整路径的搜索、执行命令的搜索、排除特定文件或目录的搜索，也可以将多种搜索条件在一次搜索中进行表达。
作为 Github 上的明星项目，fd 已有近 30k 的 star 数，同时也是基于 Rust 实现的诸多命令行工具中最具有代表性的项目之一。本文将会大致介绍 fd 的整体框架和实现逻辑，值得一提的是命令行程序会有诸多不可避免的实现上的繁琐性，对于一些细节代码，本文不会做过多展开。</p><h2 id=二整体框架><a href=#%e4%ba%8c%e6%95%b4%e4%bd%93%e6%a1%86%e6%9e%b6>#</a>
二、整体框架</h2><p><img src=/blog/p/fd/1.png width=737 height=445 srcset="/blog/p/fd/1_hu82e0c07c84ea6a698c5fd31873723806_50449_480x0_resize_box_3.png 480w, /blog/p/fd/1_hu82e0c07c84ea6a698c5fd31873723806_50449_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=165 data-flex-basis=397px></p><p>fd 使用了 jemalloc 内存分配器替换了默认的系统内存分配器。Rust 提供了一种插件式的内存分配器接口，允许开发者使用不同的内存分配器。jemalloc 是一种高效的内存分配器，尤其适用于多线程的应用程序，同时提供了内存分析能力。</p><h2 id=三过滤筛选><a href=#%e4%b8%89%e8%bf%87%e6%bb%a4%e7%ad%9b%e9%80%89>#</a>
三、过滤筛选</h2><p>fd 作为一个强大、易用的检索工具，提供了多种过滤筛选的方式。</p><h3 id=31-基于类型的筛选><a href=#31-%e5%9f%ba%e4%ba%8e%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%ad%9b%e9%80%89>#</a>
3.1 基于类型的筛选</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>FileTypes</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>files</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>directories</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>symlinks</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>sockets</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>pipes</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>executables_only</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>empty_only</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>FileTypes</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>should_ignore</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>entry</span>: <span class=kp>&amp;</span><span class=nc>dir_entry</span>::<span class=n>DirEntry</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 FileTypes 记录了需要在命令行展示文件和目录的类型。通过 should_ignore 函数将在文件系统遍历中得到的文件和目录根据 FileTypes 设置进行基于类型的筛选。</p><h3 id=32-基于权限的筛选><a href=#32-%e5%9f%ba%e4%ba%8e%e6%9d%83%e9%99%90%e7%9a%84%e7%ad%9b%e9%80%89>#</a>
3.2 基于权限的筛选</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>OwnerFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>uid</span>: <span class=nc>Check</span><span class=o>&lt;</span><span class=kt>u32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>gid</span>: <span class=nc>Check</span><span class=o>&lt;</span><span class=kt>u32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>Check</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Equal</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NotEq</span><span class=p>(</span><span class=n>T</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Ignore</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>OwnerFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>matches</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>md</span>: <span class=kp>&amp;</span><span class=nc>fs</span>::<span class=n>Metadata</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 OwnerFilter 记录需要在命令行展示文件和目录的权限范围，matches 函数根据具体的元数据来实现基于权限的筛选。</p><h3 id=33-基于大小的筛选><a href=#33-%e5%9f%ba%e4%ba%8e%e5%a4%a7%e5%b0%8f%e7%9a%84%e7%ad%9b%e9%80%89>#</a>
3.3 基于大小的筛选</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>SizeFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Max</span><span class=p>(</span><span class=kt>u64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Min</span><span class=p>(</span><span class=kt>u64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Equals</span><span class=p>(</span><span class=kt>u64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>SizeFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>is_within</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>size</span>: <span class=kt>u64</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 SizeFilter 记录基于大小的筛选条件，并提供了 is_within 函数。</p><h3 id=34-基于时间的筛选><a href=#34-%e5%9f%ba%e4%ba%8e%e6%97%b6%e9%97%b4%e7%9a%84%e7%ad%9b%e9%80%89>#</a>
3.4 基于时间的筛选</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Debug, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>TimeFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Before</span><span class=p>(</span><span class=n>SystemTime</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>After</span><span class=p>(</span><span class=n>SystemTime</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>TimeFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>applies_to</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=nc>SystemTime</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 TimeFilter 记录基于时间的筛选条件，并提供了 applies_to 函数。</p><h2 id=四文件系统遍历><a href=#%e5%9b%9b%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e9%81%8d%e5%8e%86>#</a>
四、文件系统遍历</h2><p>文件系统遍历是 fd 所需要考虑的第一个核心功能，fd 需要获取指定目录下的所有目录和文件，才能做进一步的处理、筛选和展示。事实上，fd 通过 ignore 第三方 crate 来实现这一功能，ignore crate 提供了一个快速递归目录迭代器。</p><h3 id=41-数据结构抽象><a href=#41-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%8a%bd%e8%b1%a1>#</a>
4.1 数据结构抽象</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>DirEntryInner</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Normal</span><span class=p>(</span><span class=n>ignore</span>::<span class=n>DirEntry</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>BrokenSymlink</span><span class=p>(</span><span class=n>PathBuf</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>DirEntry</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>inner</span>: <span class=nc>DirEntryInner</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>metadata</span>: <span class=nc>OnceCell</span><span class=o>&lt;</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>Metadata</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>style</span>: <span class=nc>OnceCell</span><span class=o>&lt;</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>Style</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 DirEntry 保存在文件系统遍历过程中获取的文件和目录项，并提供了一系列获取路径和元数据以及命令行显示风格的方法。</p><h3 id=42-并行遍历模式><a href=#42-%e5%b9%b6%e8%a1%8c%e9%81%8d%e5%8e%86%e6%a8%a1%e5%bc%8f>#</a>
4.2 并行遍历模式</h3><h4 id=421-数据接收缓存><a href=#421-%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6%e7%bc%93%e5%ad%98>#</a>
4.2.1 数据接收缓存</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>ReceiverMode</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Buffering</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Streaming</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[allow(clippy::large_enum_variant)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>WorkerResult</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Entry</span><span class=p>(</span><span class=n>DirEntry</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Error</span><span class=p>(</span><span class=n>ignore</span>::<span class=n>Error</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>ReceiverBuffer</span><span class=o>&lt;</span><span class=n>W</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>Config</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>quit_flag</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>AtomicBool</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>interrupt_flag</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>AtomicBool</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rx</span>: <span class=nc>Receiver</span><span class=o>&lt;</span><span class=n>WorkerResult</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>stdout</span>: <span class=nc>W</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mode</span>: <span class=nc>ReceiverMode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>deadline</span>: <span class=nc>Instant</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>buffer</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>DirEntry</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>num_results</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>W</span>: <span class=nc>Write</span><span class=o>&gt;</span><span class=w> </span><span class=n>ReceiverBuffer</span><span class=o>&lt;</span><span class=n>W</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>process</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>ExitCode</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>recv</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>WorkerResult</span><span class=p>,</span><span class=w> </span><span class=n>RecvTimeoutError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>poll</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>ExitCode</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>print</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>entry</span>: <span class=kp>&amp;</span><span class=nc>DirEntry</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>ExitCode</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>stream</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>ExitCode</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>stop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>ExitCode</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>fd 通过 channel 实现单消费者多生产者模型并构建数据流水线。当开始路径遍历过程时，fd 会 spawn 一个新的线程创建 ReceiverBuffer 数据结构，并调用其 process 函数进行循环处理。</p><p>process 函数采用了状态机模型，其中的每一次循环都会调用 poll 函数。poll 函数代表着一次数据处理或是状态转换，函数处理逻辑如下：</p><ul><li>调用 recv 函数从 channel 中接收一个数据。ReceiverBuffer 有两种接收模式，Buffering 和 Streaming 模式。在 Buffering 模式下，recv 函数会等待 channel 中的数据直到达到 ReceiverBuffer 的 deadline。而 Streaming 模式会一直等待 channel 返回数据。在默认情况下 ReceiverBuffer 初始化为 Buffering 模式。</li><li>根据 recv 函数的返回情况实现不同的行为。<ul><li>当 recv 函数成功返回一个文件或目录项时，如果当前的接收模式仍为 Buffering 模式时，将数据插入 buffer，并在 buffer 的数据量大于设置的阈值时调用 stream 函数。stream 函数会将当前的接收模式修改为 Streaming 模式，并使用 print 函数打印 buffer 中的所有文件或目录项。如果当前的接收模式为 Streaming 模式时，调用 print 函数直接打印该文件或目录项。</li><li>当 recv 函数返回超时错误时，说明在 Buffering 模式下，recv 函数在达到 deadline 时仍未接收到新数据，调用 stream 函数，打印现有 buffer 中的数据，并将接收模式修改为 Streaming 模式。</li><li>当 recv 函数返回 channel 关闭消息时，则调用 stop 方法。如果当前 ReceiverBuffer 仍为 Buffering 接收模式，则排序 buffer 中的数据并打印。</li></ul></li></ul><blockquote><p><strong>为什么需要有 Buffering 和 Streaming 两种接收模式？</strong></p><p>在文件系统遍历初期，可能有大量结果需要输出，通过缓存的方式批量输出结果降低输出压力。在达到一定的时间或数据量后，如果仍需要有数据输出，则可以切换至 FIFO 模式输出结果。</p></blockquote><h4 id=422-并行数据发送><a href=#422-%e5%b9%b6%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%8f%91%e9%80%81>#</a>
4.2.2 并行数据发送</h4><p>fd 在遍历文件系统时，会通过 ignore crate 构建一个并行的目录迭代器。并行的目录迭代器会根据设置 spawn 多个线程，每个线程会通过相同的方式处理目录迭代器产生的遍历结果。当目录迭代器返回一个遍历结果时，首先判断是否返回了错误，如果在遍历过程中发生了错误，则直接将错误通过 channel 发送至 ReceiverBuffer，ReceiverBuffer 会直接打印错误信息。然后会先根据文件或目录项的名字进行筛选，因为根据名字进行筛选不需要获取元数据，再根据第二章中提到的各种筛选方式进行筛选。当满足所有条件后，将数据发送至 ReceiverBuffer。</p><h2 id=五命令执行模型><a href=#%e4%ba%94%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b>#</a>
五、命令执行模型</h2><p>fd 不仅仅可以显示搜索的结果，也支持对搜索结果执行一系列的外部命令。fd 为搜索结果提供了两种执行外部命令的方式：</p><ul><li>-x/&ndash;exec 选项为每个搜索结果并行地运行一个外部命令；</li><li>-X/&ndash;exec-batch 选项启动外部命令一次，并将所有搜索结果作为参数。</li></ul><p>fd 还支持使用占位符语法将命令作为一种模版而不是单个字符串时用，具体来收，fd 提供了对如下占位符的支持：</p><ul><li>{}：一个占位符标记，将被搜索结果的路径所替换；</li><li>{.}：与 {} 类似，但会去除搜索结果的文件扩展名；</li><li>{/}：将被搜索结果的文件名所替换；</li><li>{//}：将被搜索结果的父目录路径所替换；</li><li>{/.}：去除搜索结果文件扩展名的文件名。</li></ul><p>当没有使用占位符时，实际上 fd 会自动在末尾加上 {}。</p><h3 id=51-命令相关数据结构抽象><a href=#51-%e5%91%bd%e4%bb%a4%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%8a%bd%e8%b1%a1>#</a>
5.1 命令相关数据结构抽象</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Clone, Debug, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Placeholder</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Basename</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Parent</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NoExt</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>BasenameNoExt</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Text</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Clone, Debug, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>ArgumentTemplate</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Tokens</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Token</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Text</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>CommandTemplate</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>args</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>ArgumentTemplate</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Token 代表着占位符的类型，ArgumentTemplate 是命令的参数单元，多个 ArgumentTemplate 组成了一个完整的命令。</p><h3 id=52-commandset-数据结构><a href=#52-commandset-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a>
5.2 CommandSet 数据结构</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>ExecutionMode</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OneByOne</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Batch</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>CommandSet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mode</span>: <span class=nc>ExecutionMode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>commands</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>CommandTemplate</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>CommandSet</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=o>&lt;</span><span class=n>I</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>S</span><span class=o>&gt;</span><span class=p>(</span><span class=n>input</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>CommandSet</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>I</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>T</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>S</span>: <span class=nb>AsRef</span><span class=o>&lt;</span><span class=kt>str</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new_batch</span><span class=o>&lt;</span><span class=n>I</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>S</span><span class=o>&gt;</span><span class=p>(</span><span class=n>input</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>CommandSet</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>I</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>T</span>: <span class=nb>IntoIterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>S</span>: <span class=nb>AsRef</span><span class=o>&lt;</span><span class=kt>str</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>execute</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>input</span>: <span class=kp>&amp;</span><span class=nc>Path</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>path_separator</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>out_perm</span>: <span class=nc>Arc</span><span class=o>&lt;</span><span class=n>Mutex</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>buffer_output</span>: <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span><span class=w> </span>-&gt; <span class=nc>ExitCode</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>execute_batch</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>paths</span>: <span class=nc>I</span><span class=p>,</span><span class=w> </span><span class=n>limit</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>path_separator</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>ExitCode</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>I</span>: <span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>CommandSet 代表 fd 需要执行的命令集合。CommandSet 有两种执行模式，OneByOne 和 Batch 模式。
在 OneByOne 模式下，调用 execute 函数会将 fd 在文件系统遍历过程中得到的单个结果依据 CommandTemplate 生成完整的命令表示，并打印输出命令执行结果。值的一提的是，OneByOne 模式并不意味着 fd 一次只会处理一个文件系统得到的遍历结果，fd 会根据设置并发多个线程对多个遍历结果执行各自的命令集合。在多个线程前提下，fd 会使用输出缓存，等待单个遍历结果全部执行完毕命令集合后一起输出最后的执行结果。如果只使用一个线程接收文件系统遍历的结果并执行命令时，fd 不使用输出缓存，而是启动一个新的进程并等待它完成。这样做的好处是允许查看中间命令输出并与之交互。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>CommandBuilder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>pre_args</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>OsString</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>path_arg</span>: <span class=nc>ArgumentTemplate</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>post_args</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>OsString</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cmd</span>: <span class=nc>Command</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>count</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>limit</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>exit_code</span>: <span class=nc>ExitCode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>CommandBuilder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>push</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>path</span>: <span class=kp>&amp;</span><span class=nc>Path</span><span class=p>,</span><span class=w> </span><span class=n>separator</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>finish</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在 Batch 模式下，调用 execute_batch 函数使用 fd 遍历文件系统得到的所有结果构造 CommandBuilder，用于在命令执行过程中添加多个结果参数。</p><blockquote><p>本文基于 v8.7.0 版本的 fd 实现。</p><p>Github 地址：https://github.com/sharkdp/fd</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/blog/tags/rust/>Rust</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Aug 17, 2023 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/blog/p/groupcache/><div class=article-details><h2 class=article-title>groupcache 支持热点填充的分布式内存缓存设计</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 zjregee</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>